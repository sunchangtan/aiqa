
# 金融问答系统元数据与数据源映射体系（管理层方案说明）

## 一、建设背景与总体方案

### 1.1 建设目标

在金融问答与查数场景中，业务方的理想体验是：

> “我用自然语言提问：**上海市国企近三年 PE/VC 事件**、**某公司 2023 年营收与净利润**，
> 系统能自动理解问题、找到正确的指标和数据源，并给出可解释的结果。”

为实现这一目标，本期建设一套**统一元数据与数据源映射体系**，将自然语言问题稳定、透明地映射到：

- 哪个实体（如个人、公司、股票、债券、基金、区域等）；
- 哪些具体字段/指标（如营收、净利、违约次数、股东列表等）；
- 通过哪些接口或数据库读取与关联。

### 1.2 核心业务抽象（只保留三个核心概念）

在业务概念层，我们刻意做“减法”，只保留三类核心业务对象：

1. **实体（Entity）**
   - 各类业务主体，如：企业、股票、债券、基金、区域等。
   - 可以理解为“行”的定义：一条企业、股票、债券、基金、区域记录。

2. **字段（Field）**
   - 挂在实体上的具体属性或度量，如：企业名称、企业性质、营收、净利润、资产总计、违约金额等。
   - 可以理解为“列”的定义：表头上的每一个字段，或者每一个指标。

3. **事件（Event）**
   - 以时间为主轴的业务事实，如：违约、评级调整、行政处罚、PE/VC 投融资事件等。
   - 从技术上看，事件本身也是一种Field，但在业务上我们强调它的“时间轴”和“行为性质”。

在实现层，我们还会用到两个“技术角色”，但它们不再引入新概念，只是对上述对象的整理与封装：

4. **关系（Relation）——“从一个实体出发的一个实体或一组关联实体”**
   - 定义：从某个实体视角看出去的一项或一组数据，例如：
     - 企业的母公司
     - 企业的股东列表
     - 企业的子公司列表
     - 企业的对外投资列表
   - 可以理解为：“从公司这条记录出发， 关联的其他一个或一组实体。”
   - 在元数据中，关系被建模为一个节点（Relation），其内部字段继续用“字段”的方式描述。

5. **视图（View）——“打包好的可查询对象或接口入口”**
   - 定义：面向业务和问答系统的“取数单元”，例如：
     - 企业基本信息视图：`company.base_info`
     - 企业风险画像视图：`company.risk_profile`
   - 对业务的含义：
     - 对外看：视图就是“某类信息的一揽子结果”，比如“企业基本信息”；
     - 对内看：视图可以对应一个接口，也可以对应多个接口/表的拼装结果。
   - 视图在元数据层面是一个独立节点（View），用于：
     - 对问答系统暴露“可直接查询的入口”；
     - 对接口映射层指示“这个视图对应哪些具体接口、返回哪些字段”。

通过这五个角色，我们在逻辑上仍然只围绕“实体 / 字段 / 事件 / 关系”四大核心概念展开，视图只是帮助组织和对外呈现，不再增加新的业务复杂度。

### 1.3 三层技术体系

整体架构拆分为三层，层次清晰、职责明确：

1. **业务语义层（Metadata Layer）**
   - 核心表：`biz_metadata`（统一元数据中心）；
   - 辅助表：`biz_metadata_alias`（别名）、`metadata_category`（分类）、`metadata_category_mapping` 等；
   - 统一描述“有哪些实体 / 字段 / 指标 / 事件 / 关系 / 视图”，以及它们之间的归属关系。

2. **数据源层（Data Source Layer）**
   - 表：`biz_data_source`、`biz_api`；
   - 描述现有 REST 接口、数据库、文件等物理数据源；
   - 不改动现有业务库和接口，只对其做“资产登记”。

3. **映射与关系层（Mapping & Relation Layer）**
   - 映射表：`biz_api_output_mapping`、`biz_api_filter_mapping`；
   - 关系表：`biz_metadata_relation`；
   - 用于描述：
     - 某语义字段在某接口响应中对应哪个字段路径；
     - 某语义字段在某接口请求中对应哪个参数、支持哪些筛选操作；
     - 不同字段之间的外键、等价、join 关系。

三层结构的目的：

- 上层：LLM 只需要理解“语义层”的实体和字段，不直接碰接口细节；
- 中层：接口与表的映射完全可配置，便于维护与审计；
- 底层：对现有业务系统影响极小，兼容既有接口与数据模型。

---

## 二、业务语义层：统一元数据中心（biz_metadata）

### 2.1 角色定位

`biz_metadata` 是统一的“字段与指标字典”，一条记录代表一个“元数据节点”：

- 一类实体：`company`、`company_finance`、`default_event`；
- 一个字段或指标：`company.name`、`company_finance.revenue`；
- 一类事件：`default_event`（违约事件）、`rating_change`（评级调整）；
- 一类关系：`company.shareholders`（股东列表）；
- 一类视图：`company.base_info`（企业基本信息视图）。

### 2.2 关键字段（业务解释）

- **code：元数据编码（全局唯一）**
  - 如：`company.name`、`company_finance.revenue`、`event.pevc.company_id`；
  - 既可用于程序内部调用，也可作为数据字典的“主键”。

- **node_type：节点类型**
  - `entity`：实体定义，如 `company`（企业）、`company_finance`（企业财务报表记录）；
  - `field`：字段/指标，如企业名称、营收、净利润；
  - `relation`：关系，如企业股东列表；
  - `view`：视图，如企业基本信息视图；
  - `event`：事件类型，如违约事件、评级调整事件。

- **owner_id：归属节点**
  - 表示“这个元数据是**谁的字段/子结构**”：
    - `company.name.owner_id = company`
    - `company_finance.revenue.owner_id = company_finance`
    - `company.shareholders.share_ratio.owner_id = company.shareholders`
  - 通过 owner，可以在元数据层面还原出“对象结构树”（实体 → 字段；关系集合 → 明细字段）。

- **value_type：值类型**
  - 控制字段数据的形态：字符串、数字、日期、列表、对象、JSON 等；
  - 对前端展示、后端计算都有指导作用。

- **semantic_type：分析语义**
  - `dimension`：用作筛选/分组的维度，如地区、行业、报表年度、企业性质等；
  - `metric`：用作统计/聚合的指标，如营收、净利润、资产总计、违约次数；
  - `text`：文本内容，如企业简介、公告正文等。

- **辅助标记**
  - `is_identifier`：是否该实体的主标识字段（如 company.company_id）；
  - `is_status`：是否状态/布尔字段（如“是否违约”、“是否存续”）；
  - `is_multi_valued`：是否多值（如标签列表、列表元素字段）；
  - `unit`、`precision`、`aggregation`：单位、精度、默认聚合方式（sum/avg/last 等）。

> 对管理层而言，可以简单理解为：
> **`biz_metadata` 把“所有实体、字段、指标、事件、关系、视图”用统一的格式“登记造册”，并附上清晰的业务解释与统计属性。**

---

## 三、业务主题与多归属：分类体系

### 3.1 业务诉求

实际使用时，业务方更习惯从“主题/模块”角度理解数据，例如：

- 企业基本信息
- 企业财务信息
- 企业风险信息
- 信用风险指标
- 监管报表 X

而不是记住 `company_finance.revenue` 这样的编码。

### 3.2 分类表与映射表

1. **metadata_category：业务分类定义**
   - 定义“企业基本信息”“企业财务信息”“企业风险信息”“信用风险”等主题；
   - 支持父子分类，可用于左侧菜单树或主题导航。

2. **metadata_category_mapping：多对多映射**
   - 将任意元数据节点（实体/字段/视图/关系）挂载到一个或多个分类下；
   - 支持多归属，例如：
     - `company.has_default_3y`（近三年是否违约）：
       - 主归属：`credit_risk`
       - 次归属：`company_risk`

> 效果：
> - 字段定义与业务主题解耦，一个字段可以出现在多个栏目中；
> - 更贴合业务认知，利于元数据管理平台和报表界面组织。

---

## 四、跨实体字段关联：biz_metadata_relation

### 4.1 背景问题

典型场景：

- 财务数据表有字段 `company_finance.company_id`；
- 企业主数据表有字段 `company.company_id`；
- 事件数据表也有 `event.pevc.company_id` 等。

业务意义上，这些字段都指向**同一个企业实体**；技术上，它们属于不同实体、存在于不同接口/表中。

我们需要一个统一、可配置的机制，来告诉系统：

> “财务表中的 company_id，外键指向企业表的 company_id；
>  事件表中的 company_id 也指向这个字段，
>  它们在 JOIN 时可以安全使用。”

### 4.2 关系表职责

`biz_metadata_relation` 用于记录“元数据之间的关系”，主要字段（业务含义）：

- `from_metadata_id`：引用端，如 `company_finance.company_id`；
- `to_metadata_id`：被引用端，如 `company.company_id`；
- `relation_type`：
  - `foreign_key`：外键关系（N→1）；
  - `same_as`：语义等价字段（例如两套系统中的同名指标）；
  - `join_key`：推荐用于 join 的字段；
  - `derived_from`：从某指标计算得来。

典型配置：

- `company_finance.company_id` → `company.company_id`，`relation_type = foreign_key`
- `event.pevc.company_id` → `company.company_id`，`relation_type = foreign_key`

### 4.3 对查询引擎的价值

在多接口、多实体联合查询时：

- Query Planner 根据 IR 知道“财务 + 企业 + 事件”都参与；
- 再根据 `biz_metadata_relation` 自动识别可用的 join 键；
- 生成“按 company_id 进行内连接”的执行计划，无需在代码中硬编码。

> 这使得“如何关联不同数据集”成为一种**元数据驱动的能力**，可配置、可审计，避免业务逻辑散落在各处代码中。

---

## 五、数据源与接口映射：打通语义与现有系统

### 5.1 数据源登记：biz_data_source

- 记录每一个数据源的基本信息：
  - 是 REST API 还是数据库；
  - 对应的引擎（REST、gRPC、MySQL、Postgres…）；
  - 连接信息、认证方式、责任团队等。
- 不改变现有系统，只做“资源登记”。

### 5.2 接口登记：biz_api

- 对每一个可用接口进行标准化描述：
  - 接口编码与名称；
  - 所属数据源；
  - URL / 表名、请求方法、协议类型；
  - 请求/响应结构（用于校验与文档）。

### 5.3 输出映射：biz_api_output_mapping

- 描述“接口返回的某个字段路径，对应哪一个语义字段”：
  - 例如：
    - `pevc_event_list` 响应中 `$.data[*].companyId` → `event.pevc.company_id`
    - `company_finance_list` 响应中 `$.data[*].revenue` → `company_finance.revenue`

这样，查询引擎只需按 `metadata_code` 取数，不需要记住接口内的字段名称，减小耦合。

### 5.4 筛选映射：biz_api_filter_mapping

- 描述“接口支持按哪些语义字段进行筛选”，以及对应的参数名和操作符：
  - 例如：
    - `pevc_event_list`：
      - `event.pevc_type` → 参数 `eventType`，支持 `eq`/`in`；
      - `event.date` → 参数 `dateFrom`/`dateTo`，支持 `between`；
      - 不支持企业地区/性质筛选；
    - `company_base_info`：
      - `company.region` → 参数 `region`；
      - `company.ownership_type` → 参数 `ownershipType`。

Query Planner 据此可以动态决定：

- 哪些过滤条件可以下推到接口层；
- 遇到接口不支持的条件时，如何通过“额外接口 + join”方式补齐。

---

## 六、端到端示例：上海市国企 PE/VC 事件

以“上海市国企 PE/VC 事件”为例，查询过程可以拆解为：

1. **用户提问**
   - 自然语言输入：“上海市国企 PE/VC 事件”。

2. **LLM 做语义识别**
   - 找到涉及的实体与事件类型：企业、PE/VC 投融资事件；
   - 识别出维度与条件：
     - 企业地区：`company.region = 上海市`
     - 企业性质：`company.ownership_type = 国企`
     - 事件类型：`event.pevc_type in {PE, VC}`；
   - 将这些自然语言概念映射到 `biz_metadata` 中的标准编码。

3. **Query Planner 做执行规划**
   - 查询映射表，发现：
     - 企业基础信息接口 `company_base_info` 支持按地区和企业性质筛选；
     - PE/VC 事件接口 `pevc_event_list` 支持按事件类型和日期筛选；
   - 查询关系表，发现：
     - `event.pevc.company_id` 外键指向 `company.company_id`；
   - 生成执行计划：
     - 调用企业接口筛选出“上海市国企企业列表”（得到企业 ID 集合）；
     - 调用事件接口筛选出“PE/VC 事件列表”（含企业 ID）；
     - 在引擎内按企业 ID 进行 join 过滤，得到“上海市国企对应的 PE/VC 事件”。

4. **结果汇总与返回**
   - 结合 `biz_metadata` 中的指标定义（单位、口径）进行结果解释；
   - LLM 可基于元数据描述生成自然语言说明；
   - 全链路可追踪：调用了哪些接口、用了哪些字段、如何 join。

---

## 七、正确性、可行性与推进建议

### 7.1 正确性与可解释性

- 所有实体、字段、事件、关系、视图都有清晰的元数据定义；
- 字段之间的外键、等价、join 关系以结构化形式记录在 `biz_metadata_relation` 中；
- 查询路径可还原：从问题到元数据，再到接口调用与 join 逻辑，满足金融场景“口径可解释、过程可审计”的要求。

### 7.2 对现有系统的影响

- 不修改现有业务表结构与接口；
- 新增的元数据与配置表可以单独部署在“元数据与问答”侧；
- 接入路径是增量的：先覆盖最核心的企业、财务、风险数据，再逐步扩展。

### 7.3 推进建议

1. **第一阶段：核心域 PoC**
   - 选定“企业 + 财务 + 违约/评级事件”为首批接入数据域；
   - 完成元数据建模、关系建模、接口映射；
   - 支撑 3–5 个典型问题的自动查数与联合分析。

2. **第二阶段：元数据管理平台**
   - 构建元数据管理后台，支持业务与数据团队可视化维护实体、字段、分类、关系、接口映射等；
   - 引入变更管控与审批流程。

3. **第三阶段：横向扩展与纵向深度应用**
   - 扩展到债券、基金、区域、风险评分等更多数据域；
   - 在风控、投研、投后管理等场景落地，减少大量人工查表与手写 SQL。

---

## 八、主要表与职责概览（便于对照）

| 表名                          | 职责概述                                                                 |
|-------------------------------|--------------------------------------------------------------------------|
| `biz_metadata`                | 统一描述所有实体/字段/指标/事件/关系/视图的业务含义与结构                |
| `biz_metadata_alias`          | 字段/指标别名，支撑自然语言同义词识别                                   |
| `metadata_category`           | 业务分类定义，构建“企业基本信息/财务/风险”等主题树                      |
| `metadata_category_mapping`   | 元数据与分类多对多映射，支持一字段多归属                               |
| `metadata_view_field`（可选） | 视图与字段的包含关系，定义视图的字段集合与默认字段                      |
| `biz_metadata_relation`       | 元数据之间的关系（外键、同义、join key、派生关系等）                    |
| `biz_data_source`             | 数据源登记（API/DB/文件等），包括引擎类型、连接方式、责任团队          |
| `biz_api`                     | 接口登记，记录路径、协议、请求/响应结构等                               |
| `biz_api_output_mapping`      | 接口响应字段 → 语义字段映射，驱动统一结果结构                           |
| `biz_api_filter_mapping`      | 接口请求参数 → 语义字段映射，描述接口支持的筛选条件及操作符             |

这套设计在保持概念简洁的前提下，构建了一个“面向实体/字段/事件的统一语义层”，并通过关系与映射机制，将其稳健地连接到现有数据源，为后续 AI 问答与自动查数能力提供了一个清晰、可演进的基础架构。
